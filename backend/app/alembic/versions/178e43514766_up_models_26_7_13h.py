"""UP models 26.7/13h

Revision ID: 178e43514766
Revises: 8769e962f301
Create Date: 2025-07-26 13:39:16.550052

"""
from alembic import op
import sqlalchemy as sa
import sqlmodel.sql.sqltypes
from sqlalchemy.dialects import postgresql # Thêm import này cho UUID
import uuid # Thêm import này để tạo UUID ngẫu nhiên

# revision identifiers, used by Alembic.
revision = '178e43514766'
down_revision = '8769e962f301'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    # --- BƯỚC 1: THÊM CÁC CỘT MỚI ---

    # Thêm cột 'port' vào bảng 'ecopark'
    op.add_column('ecopark', sa.Column('port', sa.Integer(), nullable=True)) # Tạm thời nullable=True để tránh lỗi nếu có dữ liệu cũ
    op.create_index(op.f('ix_ecopark_port'), 'ecopark', ['port'], unique=True) # Tạo index unique

    # Thêm cột 'port' vào bảng 'detalecoretreat'
    op.add_column('detalecoretreat', sa.Column('port', sa.Integer(), nullable=True)) # Tạm thời nullable=True
    op.create_index(op.f('ix_detalecoretreat_port'), 'detalecoretreat', ['port'], unique=False)


    # --- BƯỚC 2: XỬ LÝ CHUYỂN ĐỔI 'ecopark.id' TỪ INTEGER SANG UUID ---
    # Đây là phần chính cần sửa để tránh lỗi 'CannotCoerce'

    # 1. Xóa ràng buộc khóa chính cũ trên cột 'id' (kiểu INTEGER)
    op.drop_constraint('ecopark_pkey', 'ecopark', type_='primary')

    # 2. Đổi tên cột 'id' (INTEGER) thành 'old_id_int'
    # Điều này giữ lại dữ liệu cũ nếu bạn cần tham chiếu nó
    op.alter_column('ecopark', 'id', new_column_name='old_id_int', existing_type=sa.INTEGER(), existing_nullable=True)


    # 3. Thêm một cột 'id_uuid' mới với kiểu UUID và là primary key
    op.add_column('ecopark', sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=sa.text('uuid_generate_v4()'), nullable=False))
    # Hoặc nếu không muốn sử dụng default trong SQL, bạn có thể tạo UUID trong Python và insert/update
    # Đối với migration, `uuid_generate_v4()` là cách tiêu chuẩn.
    # Đảm bảo bạn đã kích hoạt extension uuid-ossp trong PostgreSQL nếu chưa: CREATE EXTENSION IF NOT EXISTS "uuid-ossp";


    # 4. Cập nhật cột 'id' (UUID mới) cho các bản ghi hiện có
    # Đây là bước quan trọng nếu bạn có dữ liệu cũ.
    # Chúng ta sẽ tạo một UUID ngẫu nhiên cho mỗi hàng hiện có.
    # op.execute(
    #     "UPDATE ecopark SET id = uuid_generate_v4() WHERE id IS NULL"
    # )
    # Dòng trên là cần thiết nếu bạn tạo cột 'id' mà không có default.
    # Với `default=sa.text('uuid_generate_v4()')`, PostgreSQL sẽ tự điền.
    # Tuy nhiên, nếu bạn có bản ghi CŨ mà 'id' của nó đã là số nguyên và bạn đã đổi tên thành 'old_id_int',
    # thì PostgreSQL sẽ không tự điền 'id' mới cho các bản ghi đó.
    # Bạn có thể cần một vòng lặp hoặc lệnh UPDATE phức tạp hơn nếu muốn ánh xạ lại.
    # NHƯNG, yêu cầu của bạn là 'id' là UUID và 'port' là INT.
    # Nếu bạn chỉ đơn giản muốn các bản ghi cũ có UUID mới và không quan tâm đến ánh xạ old_id_int -> new_uuid, thì:
    # SQLModel tự động tạo default_factory nếu bạn để primary_key=True và default_factory.
    # Trong migration, việc thêm cột mới với primary_key=True và default như trên sẽ tự động xử lý các giá trị mới.
    # Đối với các bản ghi cũ, chúng ta không cần UPDATE rõ ràng, vì chúng sẽ có 'id' là NULL
    # (nếu bạn không cung cấp giá trị khi thêm cột mới).
    # LƯU Ý: Với `nullable=False` và `primary_key=True`, cột mới phải có giá trị cho các hàng hiện có.
    # Alembic/SQLAlchemy sẽ không cho phép thêm cột `NOT NULL` mà không có `DEFAULT` hoặc `server_default`
    # nếu có các hàng hiện có mà không cung cấp giá trị.
    # Vì vậy, tốt nhất là thêm `default=sa.text('uuid_generate_v4()')` trực tiếp khi thêm cột mới.


    # 5. Xóa cột 'old_id_int' (ID cũ kiểu INTEGER)
    op.drop_column('ecopark', 'old_id_int')


    # --- BƯỚC 3: XÓA CÁC CỘT CŨ (và khóa ngoại cũ) ---

    # Xóa cột 'building' khỏi bảng 'detalecoretreat'
    op.drop_column('detalecoretreat', 'building')

    # Xóa khóa ngoại 'ecopark_project_id_fkey' và cột 'project_id' khỏi bảng 'ecopark'
    # Đảm bảo tên khóa ngoại đúng.
    # op.drop_constraint('ecopark_project_id_fkey', 'ecopark', type_='foreignkey') # <- Vẫn kiểm tra lại tên này
    op.drop_column('ecopark', 'project_id')


    # --- BƯỚC 4: THÊM CÁC RÀNG BUỘC MỚI (Khóa ngoại, Nullable) ---

    # Thay đổi nullable của các cột 'port' thành False (nếu cần thiết và đã điền dữ liệu)
    # Nếu bạn đặt nullable=True ở trên để tránh lỗi, giờ là lúc đổi nó thành False
    # op.alter_column('ecopark', 'port', existing_type=sa.Integer(), nullable=False)
    # op.alter_column('detalecoretreat', 'port', existing_type=sa.Integer(), nullable=False)


    # Thêm khóa ngoại cho 'detalecoretreat.port' trỏ đến 'ecopark.port'
    # BƯỚC NÀY PHẢI ĐẶT SAU CÙNG, khi tất cả các cột đã được tạo và các ràng buộc PK đã được thiết lập
    op.create_foreign_key(op.f('fk_detalecoretreat_port_ecopark'),
                          'detalecoretreat', 'ecopark',
                          ['port'], ['port'])

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###

    # --- BƯỚC 1: XÓA CÁC RÀNG BUỘC MỚI ---

    # Xóa khóa ngoại đã tạo trong upgrade
    op.drop_constraint(op.f('fk_detalecoretreat_port_ecopark'), 'detalecoretreat', type_='foreignkey')

    # --- BƯỚC 2: ĐẢO NGƯỢC THAY ĐỔI KIỂU DỮ LIỆU VÀ KHÓA CHÍNH CỦA 'ecopark.id' ---

    # 1. Đổi tên cột 'id' (UUID) thành 'old_id_uuid'
    op.alter_column('ecopark', 'id', new_column_name='old_id_uuid', existing_type=postgresql.UUID(as_uuid=True), existing_nullable=False)

    # 2. Thêm lại cột 'id' kiểu INTEGER và là khóa chính
    op.add_column('ecopark', sa.Column('id', sa.Integer(), autoincrement=True, primary_key=True, nullable=False))
    # Nếu bạn có dữ liệu cũ muốn khôi phục, bạn sẽ cần logic để map old_id_uuid -> id (INTEGER)
    # Thường thì việc downgrade kiểu dữ liệu này là mất dữ liệu hoặc cần logic phức tạp
    # Ví dụ: op.execute("UPDATE ecopark SET id = (SELECT MIN(temp_id) FROM generate_series(1, COUNT(*)) AS temp_id) WHERE id IS NULL;")
    # NHƯNG, đây là một thao tác rất không an toàn và gần như luôn mất dữ liệu nếu bạn đã tạo UUID ngẫu nhiên.
    # Trong môi trường production, bạn sẽ không bao giờ thực hiện downgrade kiểu dữ liệu như thế này.
    # Đối với mục đích phát triển, việc TRUNCATE TABLE trước khi downgrade thường an toàn hơn.

    # 3. Xóa cột 'old_id_uuid'
    op.drop_column('ecopark', 'old_id_uuid')


    # --- BƯỚC 3: THÊM LẠI CÁC CỘT CŨ VÀ KHÓA NGOẠI CŨ (nếu có) ---

    # Thêm lại cột 'project_id' vào bảng 'ecopark'
    op.add_column('ecopark', sa.Column('project_id', postgresql.UUID(as_uuid=True), autoincrement=False, nullable=True))
    # Thêm lại khóa ngoại cũ (nếu có và nếu bạn muốn khôi phục lại mối quan hệ)
    # op.create_foreign_key(op.f('ecopark_project_id_fkey'), 'ecopark', 'projectlist', ['project_id'], ['id'])

    # Thêm lại cột 'building' vào bảng 'detalecoretreat'
    op.add_column('detalecoretreat', sa.Column('building', sa.VARCHAR(), autoincrement=False, nullable=True)) # Giả định kiểu VARCHAR

    # --- BƯỚC 4: XÓA CÁC CỘT 'port' MỚI ---

    # Xóa index và cột 'port' khỏi bảng 'ecopark'
    op.drop_index(op.f('ix_ecopark_port'), table_name='ecopark')
    op.drop_column('ecopark', 'port')

    # Xóa index và cột 'port' khỏi bảng 'detalecoretreat'
    op.drop_index(op.f('ix_detalecoretreat_port'), table_name='detalecoretreat')
    op.drop_column('detalecoretreat', 'port')

    # ### end Alembic commands ###